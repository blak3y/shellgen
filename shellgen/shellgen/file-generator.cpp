#include "file-generator.hpp"

#include <fstream>
#include <map>

shellgen::FileGenerator::FileGenerator(std::filesystem::path& folderPath, std::vector<Function>& functionList) : m_FolderPath(folderPath), m_FunctionList(functionList)
{
	if (!std::filesystem::exists(folderPath)) {
		std::filesystem::create_directory(folderPath);
	}
}

shellgen::FileGenerator::~FileGenerator()
{
	m_FunctionList.clear();
}

void shellgen::FileGenerator::CreateFiles()
{
	std::map<std::string, std::vector<Function>> functionGroups{};
	for (auto& function : m_FunctionList)
	{
		auto group = functionGroups.find(function.group);
		if (group == functionGroups.end())
		{
			// group doesn't exist create a new one
			functionGroups.emplace(function.group, std::vector<Function>());
			group = functionGroups.find(function.group);
		}

		// Add function to the group
		group->second.emplace_back(function);
	}

	for (auto group = functionGroups.begin(); group != functionGroups.end(); group++)
	{
		std::string fileData = GenerateFileData(group->first, group->second);
		std::ofstream file = std::ofstream(m_FolderPath / std::string(group->first + ".hpp"));
		file << fileData;
	}
}

std::string shellgen::FileGenerator::GenerateFileData(std::string group, std::vector<Function> functionList)
{
	std::stringstream fileData;

	fileData << "#pragma once\n\n";
	fileData << "// Generated by shellgen, an shellcode generation tool.\n\n";
	fileData << "namespace " << group << "\n{\n";

	fileData << "\tstruct ImportData {\n";
	fileData << "\t\tchar moduleName[32];\n";
	fileData << "\t\tchar importName[32];\n";
	fileData << "\t\tunsigned int offset;\n";
	fileData << "\t};\n\n";

	for (auto& function : functionList)
	{
		fileData << "\tnamespace " << function.metadata.name << "{\n";

		fileData << "\t\tstatic unsigned char bytes[" << function.bytes.size() << "] = {";
		for (size_t i = 0; i < function.bytes.size(); i++) 
		{
			fileData << "0x" << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(function.bytes[i]);

			if (i < function.bytes.size() - 1) {
				fileData << ",";
			}
		}
		fileData << "};\n";

		fileData << "\t\tstatic unsigned int variables[" << function.variables.size() << "] = {";
		for (size_t i = 0; i < function.variables.size(); i++)
		{
			fileData << "0x" << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(function.variables[i].offset);

			if (i < function.variables.size() - 1) {
				fileData << ",";
			}
		}
		fileData << "};\n";

		fileData << "\t\tstatic ImportData dynamicImports[" << function.dynamicImports.size() << "] = {\n";
		for (size_t i = 0; i < function.dynamicImports.size(); i++)
		{
			auto& dynamicImport = function.dynamicImports[i];

			fileData << "\t\t\t{ \"" << dynamicImport.moduleName << "\","
				<< "\"" << dynamicImport.functionName << "\","
				<< "0x" << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(dynamicImport.offset)
				<< " }";

			if (i < function.dynamicImports.size() - 1) {
				fileData << ",";
			}

			fileData << "\n";
		}
		fileData << "\t\t};\n";

		//fileData << 

		fileData << "\t}\n";
	}

	fileData << "}";

	return fileData.str();
}
